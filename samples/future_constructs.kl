fn main() {
	var option = Some(42);
	if option is Some(num) {
		print(num)
	}

	var n = 10;
	while n != 0 {
		n = n - 1;
		n -= 1;
	}

	var cond = true;
	while cond.! // or cond.not() (e.g. `vec.is_empty().not()`)
		and cond is true
	{
		// snip
	}

	var stmts = [];

	var stmts_iter = stmts.iter();
	while stmts_iter.next() is Some(stmt) { }

	in stmts for stmt { }
	in stmts the stmt { }
	for stmts each stmt { /* snip */ }
	for stmts be stmt { }
	all stmts be stmt { }
	loop stmts for stmt { }

	stmts.for |stmt| { }
	stmts.iter().enumerate().for |i, stmt| { }

	for Struct impl Trait { }
	Struct::impl Trait { }
	Struct.impl Trait { }
	Struct.impl { }

	cst og_num = 10;
	var myref = &og_num;
	var mynum = myref.*;
	
	var res = Ok(98);
	var num = res.?;

	var num = 123;
	match num {
		123 -> {}
		else -> {}

		123 => {}
		else => {}

		// no arrows
		123 { 456 }
		_ {
			// -snip-
		}
	}

	// annotate functions as such
	var myexpr = f() : uint;

	var myvec = (
		(1..=100)
			.into_iter()
			.collect() : Vec<_>
	)
	.into_iter()
	.map((|x| x+1):fn(uint) -> uint);
}
